source assem.tcl

E PIA 0x4000
E PORTA 0x4000
E PORTB 0x4001
E CTRLA 0x4002
E CTRLB 0x4003

# Page 0 addresses
E count 0x6b
E tmp2 0x6c
E tmp3 0x6d
E chksum 0x6d
E ptr 0x6e
E addr 0x70
E nmivec 0x72
E irqvec 0x74
E tmpX 0x76
E usrsp 0x78
E dbuf 0x7a

# Scan codes
E keyCN 0x25
E keyG 0x35
E keyI 0x32
E keyL 0x05
E keyM 0x31
E keyP 0x15
E keyR 0x30

E . 0x7c00
L keycode
B 0x22 0x24 0x02 0x12 0x14 0x00 0x10 0x04 
B 0x01 0x11 0x03 0x13 0x23 0x33 0x21 0x20

L svnseg
B 0x7e 0x06 0x5b 0x1f 0x27 0x3d 0x7d 0x0e 
B 0x7f 0x3f 0x6f 0x75 0x78 0x57 0x79 0x69

L GETKEY
I   push B

L getkey0
# Set up I/O port
I   clr A
I   st A CTRLA
I   st A CTRLB
I   st A PORTA
I   ld A #0xf
I   st A PORTB
I   ld A #0x4
I   st A CTRLA
I   st A CTRLB
I   ld B #0xff

L getkey2
I   inc B
I   cmp B #4
I   bne getkey1
I   bsr DISPRESH
I   bra getkey0

L getkey1
I   st B PORTB
I   ld A PORTA
I   com A
I   beq getkey2

# Found a key: decode it
I   st B tmp2
I   st A tmp3
I   clr A
I   ld B #1

L getkey4
I   cmp B tmp3
I   beq getkey3
I   inc A
I   asl B
I   beq getkey2
I   bra getkey4

L getkey3
I   ld B tmp2
I   asl B
I   asl B
I   asl B
I   asl B
I   add A B

# Wait for the key to be released
I   push A
I   ld A #8
I   st A tmp3
L getkey6 
I   clr B
L getkey5
I   ld A PORTA
I   com A
I   bne getkey6
I   dec B
I   bne getkey5
I   dec tmp3
I   bne getkey5
I   pop A
I   pop B
I   rts

# 7c7b
L DISPRESH
I   push A
I   push B
I   st X tmpX

# Set output ports for display
I   ld X #PIA
I   clr A
I   st A 2(X)
I   st A 3(X)
I   ld A #0x7f
I   st A 0(X)
I   ld A #0x0f
I   st A 1(X)
I   ld A #0x4
I   st A 2(X)
I   st A 3(X)

# Initialise loop over digits
# They are numbered 4..9 to correspond to outputs from the 7442 decoder.
I   ld X #dbuf-1
I   ld B #3

L disp2
I   inc B
I   cmp B #10
I   bne disp3

# Finished
I   ld X tmpX
I   pop B
I   pop A
I   rts

# Light up the next digit
L disp3
I   inc X
I   st B PORTB
I   ld A (X)
I   com A
I   st A PORTA

# Delay loop
I   ld A #0x80
L disp1
I   dec A
I   bne disp1

# Loop for next digit
I   bra disp2

L BADDR
# Input 2 byte address into X; result also at [addr]
I   clr A
I   st A dbuf
I   st A dbuf+1
I   st A dbuf+2
I   st A dbuf+3
I   ld X #dbuf
I   bsr HEXIN
I   st A addr
I   bsr HEXIN
I   st A addr+1
I   ld X addr
I   rts

# 7ccc
L HEXIN
# Input 2 hex digits into A and update display at X
I   bsr KEYHEX
I   asl A
I   asl A
I   asl A
I   asl A
I   push A
I   bsr L7SEG
I   st A (X)
I   inc X
I   bsr KEYHEX
I   pop B
I   add A B
I   push A
I   bsr R7SEG
I   st A (X)
I   inc X
I   pop A
I   rts

# 7ce4
L KEYHEX
I   jsr GETKEY
# Fall-thru

L HEXCON
I   push B
I   st X tmpX
I   ld X #keycode-1
I   ld B #0xff
L hexcon1
I   inc B
I   inc X
I   cmp X #keycode+16
I   beq toresume2
I   cmp A (X)
I   bne hexcon1
I   mov A B
I   ld X tmpX
I   pop B
I   rts

# 7cff
L L7SEG
I   asr A
I   asr A
I   asr A
I   asr A
# Fall-thru

# 7d03
L R7SEG
# Convert low-order 4 bits of A to 7seg
I   st X tmpX
I   ld X #svnseg
I   and A #0xf
L r71
I   beq r72
I   inc X
I   dec A
I   bra r71
L r72
I   ld A (X)
I   ld X tmpX
I   rts

# 7d15
L SVNHEX
# Convert 7seg to hex
I   push B
I   st X tmpX
I   ld X #svnseg
I   mov B A
I   clr A

L svnhex1
I   cmp B (X)
I   beq svnhex2
I   inc X
I   cmp X #svnseg+16
L toresume2
I   beq resume
I   inc A
I   bra svnhex1

L svnhex2
I   ld X tmpX
I   pop B
I   rts

# 7d2e
L memdisp
# Prompt for address with M and display memory contents
I   clr A
I   st A dbuf+4
I   ld A #0x6e
I   st A dbuf+5
I   jsr BADDR

L mem0
I   ld A (X)
I   push A
I   bsr L7SEG
I   st A dbuf+4
I   pop A
I   bsr R7SEG
I   st A dbuf+5

L mem1
# Check for I key
I   jsr GETKEY
I   cmp A #0x32
I   beq mem2
I   bsr HEXCON
I   ld B dbuf+5
I   st B dbuf+4
I   bsr R7SEG
I   st A dbuf+5
I   bra mem1

L mem2
# Store and increment
I   ld A dbuf+4
I   bsr SVNHEX
I   asl A
I   asl A
I   asl A
I   asl A
I   push A
I   ld A dbuf+5
I   bsr SVNHEX
I   pop B
I   add A B
I   mov B A
I   st A (X)
I   ld A (X)
I   cmp A B
I   bne resume
I   inc X
I   st X addr
I   ld A addr
I   bsr L7SEG
I   st A dbuf
I   ld A addr
I   bsr R7SEG
I   st A dbuf+1
I   ld A addr+1
I   jsr L7SEG
I   st A dbuf+2
I   ld A addr+1
I   jsr R7SEG
I   st A dbuf+3
I   bra mem0

L reset
# Reset handler
I   ld SP #0x60

L nmisr
I   st SP usrsp

# Set up NMI to point here
I   ld X #nmisr
I   st X nmivec

# 7d97
L resume
I   ld SP #0x60

# Clear display
I   clr A
I   ld B #5
I   ld X #dbuf+1
L reset1
I   st A (X)
I   inc X
I   dec B
I   bne reset1

# Show '-' at left
I   inc A
I   st A dbuf

I   jsr GETKEY

# If key is 'M'
I   cmp A #keyM
I   bne reset2
I   jmp memdisp
L reset2
# If key is 'R'
I   cmp A #keyR
I   beq regdisp
# If key is 'G'
I   cmp A #keyG
I   beq go
# If key is 'CN'
I   cmp A #keyCN
I   beq cont
# If key is 'L'
I   cmp A #keyL
I   bne reset3
I   jmp load
# If key is 'P'
L reset3
I   cmp A #keyP
I   bne resume
I   jmp save

# 7dcd
L go
# Prompt and accept start address
I   ld A #0x7c
I   st A dbuf+5
I   jsr BADDR
I   st X tmpX
I   ld X usrsp
I   ld A tmpX
I   st A 6(X)
I   ld A tmpX+1
I   st A 7(X)

# 7de0
L cont
I   ld SP usrsp
I   rti

L swintr
# SWI handler: display registers
I   st SP usrsp
I   ld SP #0x60

# 7de8
L regdisp
# Display registers one at a time
I   ld X usrsp

# Show CC
I   ld A #0x78
I   st A dbuf+4
I   st A dbuf+5
I   clr A
I   st A dbuf
I   st A dbuf+1
I   bsr showbyte
I   bsr regwait

# Show B
I   clr dbuf+4
I   ld A #0x75
I   st A dbuf+5
I   bsr showbyte
I   bsr regwait

# Show A
I   ld A #0x6f
I   st A dbuf+5
I   bsr showbyte
I   bsr regwait

# Show X as IH
I   ld A #0x6
I   st A dbuf+4
I   ld A #0x67
I   st A dbuf+5
I   bsr showword
I   bsr regwait

# Show PC
I   ld A #0x68
I   st A dbuf+4
I   ld A #0x78
I   st A dbuf+5
I   bsr showword
I   bsr regwait

# Show SP
I   ld A #0x3d
I   st A dbuf+4
I   ld A #0x6b
I   st A dbuf+5
I   ld X #usrsp
I   dec X
I   bsr showword
I   bsr regwait
I   bra toresume

# 7e36
L showleft
# Fetch a byte at ++X and display it in the left two digits
I   inc X
I   ld A (X)
I   jsr L7SEG
I   st A dbuf
I   ld A (X)
I   jsr R7SEG
I   st A dbuf+1
I   rts

# 7e46
L showword
# Show a two-byte word
I   bsr showleft
# Fall-thru

# 7e48
L showbyte
# Fetch a byte at ++X and display it
I   inc X
I   ld A (X)
I   jsr L7SEG
I   st A dbuf+2
I   ld A (X)
I   jsr R7SEG
I   st A dbuf+3
I   rts

# 7e58
L regwait
# Wait for I key or resume monitor
I   jsr GETKEY
I   cmp A #keyI
I   beq gotI
L toresume
I   jmp resume
L gotI
I   rts

# ----------------------------------------------------------------

L recvbit
# Receive a bit and return in CC
I   push A
I   push B

L retry
I   ld B #6

# Listen for a high signal on PORTB[7]
L recv1
I   ld A PORTB
I   asl A
I   bcc recv1

# Wait a moment
L recv2
I   dec B
I   bne recv2

# Check the signal is still high
I   ld A PORTB
I   asl A
I   bcc retry

# Time until the signal is low
I   ld B #40
L recv3
I   dec B
I   ld A PORTB
I   asl A
I   bcs recv3

# Show a bit pattern in the display
I   ld A #0xef
I   tst B
I   bmi recv4
I   asr A
L recv4
I   st A PORTA

# Set CC with the result: positive for a 1
I   tst B
I   pop B
I   pop A
I   rts

# 7e8c
L recvbyte
# Receive a byte and return in B
I   push A

# Wait for start bit
L rbyte1
I   bsr recvbit
# 7e8f
I   bpl rbyte1

# Prepare to gather 8 bits
I   ld A #8

# Loop once per bit, LSB first
L rbyte3
I   bsr recvbit
I   clc
I   bmi rbyte2
I   sec
L rbyte2
I   ror B
I   dec A
I   bne rbyte3

I   pop A
I   rts

L load
# Set up I/O ports
I   ld X #0
I   st X CTRLA
I   ld X #0xff7f
I   st X PORTA
I   ld X #0x0404
I   st X CTRLA
I   ld X #0xff04
I   st X PORTA

L reload
I   bsr recvbyte
# Wait for 0x53 = 'S'
I   cmp B #0x53
I   bne reload
I   bsr recvbyte
# Code 'S1' begins a record
I   cmp B #0x31
I   beq load2
# Code 'SJ' means EOF
I   cmp B #0x4a
I   bne reload

L messageF
# Show F in display forever
I   ld A #0x69
I   bra errstop

L load2
# Get count, initialise checksum
I   bsr recvbyte
I   st B tmp2
I   mov A B

# Get two-byte address, accumulating checksum in A
I   bsr recvbyte
I   st B tmpX
I   add A B
I   dec tmp2
I   bsr recvbyte
I   st B tmpX+1
I   add A B
I   ld X tmpX

L ldloop
I   dec tmp2
I   beq lddone
I   bsr recvbyte
I   st B (X)
I   add A B
I   inc X
I   bra ldloop

L lddone
# Verify checksum
I   bsr recvbyte
I   add A B
I   beq reload
I   ld A #0x78
# Fall-thru

L errstop
# Show code from A and loop forever
I   ld X #0
I   st X dbuf
I   st X dbuf+2
I   st X dbuf+4
I   st A dbuf
L dead
I   jsr DISPRESH
I   bra dead

I   nop
I   nop
I   nop
I   nop

# ----------------------------------------------------------------

L save
# Prompt 'S' and get start address
I   ld X #0x3d
I   st X dbuf+4
I   jsr BADDR
I   st X ptr

# Prompt 'F' and get finish address
I   ld A #0x69
I   st A dbuf+5
I   jsr BADDR

# Set up output port
I   clr A
I   st A CTRLB
I   dec A
I   st A PORTB
I   ld A #0x04
I   st A CTRLB
I   clr A
I   st A PORTB
I   bra save1

I   nop
I   nop
I   nop
I   nop

# 7f2f
L savedone
I   bra messageF

# 7f31
L save1
# Send two bytes of all ones
I   ld A #0xff
I   bsr send
I   bsr send

# 7f37
L save4
# Send block start
I   bsr sendstart

# calculate block length
I   ld A #0xff
I   ld B ptr+1
I   sub A B

# 7f3e
L save2
# Send length code and init checksum
I   and A #0xf
I   add A #3
I   bsr send
# 7f44
I   st A chksum

# Send (half of) address and add to checksum
I   ld X #ptr
I   bsr sendbyte
# 7f4b
I   add A chksum
I   st A chksum

# Send other half of address and add to checksum
I   inc X
I   bsr sendbyte
# 7f52
I   add A chksum
I   st A chksum
I   ld X ptr

# Send a data byte and add to checksum
L save3
I   bsr sendbyte
# 7f5a
I   add A chksum
I   st A chksum

# Test if finished
I   cmp X addr
#7f60
I   beq endblock

# Increment and test if end of block
I   inc X
I   st X ptr
I   ld A ptr+1
I   bit A #0xf
I   bne save3
# 7f6b

L endblock
# Send checksum
I   ld A chksum
I   neg A
I   bsr send

# Test if all finished
I   cmp X addr
I   beq sendeof

# 7f74 
# Test if another full block to send
I   ld A ptr
I   cmp A addr
I   bmi save4
# 7f7a
I   ld B ptr+1
I   ld A addr+1
I   and A #0xf0
# 7f80
I   cmp A B
I   bne save4
# 7f83
# Last block may be short
I   bsr sendstart
# 7f85
I   ld A addr+1
I   bra save2

# 7f89
L sendeof
# Send eof code 534a = 'SJ'
I   ld A #0x53
I   bsr send
I   ld A #0x4a
I   bsr send
I   bra savedone

# 7f93
L sendstart
# Send magic code 'S1'
I   ld A #0x53
I   bsr send
I   ld A #0x31
I   bra send

# 7f9b
L sendbyte
# Transmit byte from (X)
I   ld A (X)

# 7f9d
L send
# Transmit byte from A
I   push A
I   push B

# Total of 10 bits to send, including start and stop
I   ld B #10
I   st B count

# Set up start bit
I   clc

L nextbit
# Next bit in C flag: set B to delay count
I   ld B #0x78
I   bcc save8
I   ld B #0x1e
L save8
I   push B

# Set bit in output port
I   ld B #0x40
I   st B PORTB

# Delay loop
I   pop B
I   dec SP
L delay1
I   dec B
I   bne delay1

# Clear bit in output port
I   st B PORTB

# Same delay loop again
I   pop B
L delay2
I   dec B
I   bne delay2

# Rotate a 1 bit into A, so stop bit will be a 1
I   sec
I   ror A
I   dec count
I   bne nextbit

I   pop B
I   pop A
I   rts

E . 0x7fe8
L intrq
# IRQ handler
I   ld X irqvec
I   jmp (X)

E . 0x7fec
L nmintr
# NMI handler
I   ld X nmivec
I   jmp (X)

E . 0x7ff8
# Interrupt vectors
W intrq
W swintr
W nmintr
W reset

fixup
output
